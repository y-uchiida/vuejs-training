## コンポーネント間のデータ連携

### 親から子へのデータ引き渡し: props
子コンポーネントで、親から受け取るデータ名称をpropsで指定しておく  
コンポーネントの利用時に、タグの属性として値を渡す  

~~~JavaScript
export default {
	/* propsで値を設定 */
	props: {
		'linkedValue1': {
			type: Number,
			required: true,
		},
		'linkedValue2': {
			type: String,
			default: "hello world"
		},
		'linkedValue3': {
			type: Object,
			default: function(){ /* プリミティブ型以外の場合、デフォルト値の指定は関数の返り値として設定する */
				return {'name': 'John', age: 25}
			}
		}
	},
	/* 初期値や型を決めずに、データ名だけ設定する場合は配列形式でも記述できる */
	//props: ["value1", "value2", "value3"],
	data() {
		return {}
	}
}
~~~

親コンポーネント側での呼び出しの記述は以下のようになる  
~~~JavaScript
<SampleComponent linked-value1="test" v-bind:linked-value="myObj"></SampleComponent>
~~~

子コンポーネント側で
プロパティの受け渡しの際、HTMLの要素のように記述する場合はケバブケースの記述をすると良い  

子コンポーネント内で値を利用する場合は、`data()`で指定されたときと同じように`this.`

### 子コンポーネントから親コンポーネントへ値を渡す: $emit
`$emit()` で、イベントを作成して発火することができる  
`this.$emit(イベント名称 [, 渡すデータの値])` でイベント名とデータの値を記述できる(値は省略可能)  
このイベントは親コンポーネント側からイベントハンドラで扱える  
子コンポーネントから発火したカスタムイベントの内容によって  親コンポーネントのデータを変化させるハンドラを  
作成しておくことで、値を受け取ったような動作を作ることができる  
Vue 3 から、コンポーネントが発火するカスタムイベントは `emits` で宣言しておくことができるようになった  
宣言していないカスタムイベントを発火させると、警告が発生する  

~~~JavaScript
/* カスタムイベント名をemits で事前に定義しておく */
<script>
export default {
	emits: ['custom-event'],
	data() {
		return {
			/* データ */
		}
	},
}
</script>

/* ChildComponent 側で以下のように記述すると、カスタムイベントが親コンポーネントからも検出される */
this.$emit('custom-event', data)
// -> コンポーネントを呼び出した親コンポーネント側で、カスタムイベントのハンドラを書ける
~~~

~~~JavaScript
<ParentComponent>
	<ChildComponent v-on:custom-event="someFunction" />
</ParentComponent>

<script>
	export default {
		methods: {
			someFunction: function(eventData){
				/* 引数から、カスタムイベントで送られてきたデータを受け取ることができる */
				console.log(eventData)
			}
		}
	}
</script>
~~~

### データフローは親→子 への単一方向になっている
子コンポーネント側から親コンポーネントのデータの値を直接書き換えてしまうと、  
値がいつ、どこで変化したのかわかりづらくなる恐れがあるため、フレームワークの側で制約を設けている  
子コンポーネント側からはあくまでカスタムイベントの発火とそれに伴う値を提供するのみとして、  
親コンポーネントが子コンポーネントに依存することがないような設計にされている

### オブジェクト型のデータをpropsで渡す場合、参照渡しになる点に注意
プリミティブ型は値渡しされるが、配列やオブジェクトなどのオブジェクト型データは、  
親から渡されたデータの参照が子コンポーネントのpropsに代入される  
「子コンポーネントから親コンポーネントのデータが書き換えられることはない」と思っていると思わぬバグにつながるので注意

### カスタムイベント名はケバブケースがよい
カスタムイベントは、VueのJavaScript 側から呼び出すことは殆どない(`$emits()` 引数の文字列として記述されるくらい)  
むしろ、templateタグ内で`v-on` などと組み合わせて使うことが多い  
そのため、JavaScriptの命名規則らしさ(パスカルケースとかキャメルケース)よりも、  
htmlのタグ名と混同しないようにケバブケースを使ったほうがよい  

## スロット
props で渡せるのは値であり、DOM要素を含めて渡すのは非効率で見通しも悪くなる  
コンポーネントの中に、外側からコンテンツを差し込むための機能として、スロットが実装されている

~~~JavaScirpt
<template>
	<slot>デフォルトの表示(フォールバックコンテンツ)</slot>
</template>
~~~

~~~JavaScript
/* 親コンポーネントで、以下のように利用できる */
<ChildComponent>
	<template v-slot>差し込みたいコンテンツを記述</template>
</ChildComponent>
~~~
コンテンツの差し込みはDOM要素をそのまま渡すことができる

### スロットのスコープ
Vueのコンポーネントは、親子関係があっても自分以外のコンポーネントのデータにアクセスできない  
sytle要素の設定は、親コンポーネント側・子コンポーネント側どちらに書かれているものでも適用される  
同じ要素に対してスタイルしていがあるときは、スコープのほうが上書きの内容なので、  
それが記述されている親コンポーネントのものが適用される  

### 複数のスロット(名前付きスロット)
複数の`<slot></slot>`を記述した場合、それぞれに呼び出し元から渡されたDOM要素が差込される  

### 子コンポーネントのデータに、スロットからアクセスする(v-slot ディレクティブ)
異なるDOMのコンテンツを渡したい場合、名前付きスロットを利用することで実現できる  

`<slot name="sample"></slot>` のように記述すると、  
呼び出し側で`<template v-slot:sample /></template>` で囲まれた部分のコンテンツを差し込むことができる  

なお、単に`<slot></slot>`と記述した場合、`<slot name="default"></slot>` と記述したものとみなされる  

### v-slot ディレクティブの省略記法
`v-slot` は #で置き換えることができる  
`v-slot:name` の場合、 `#name` と記述でき、slotプロパティを持つ場合は`#name="slotProps"` のようにできる  

### 動的なスロット名
`v-slot:[ 変数名 ]` のように、`[ ]` で囲むと、dataで設定した変数の値をslot名として利用できる  

## 動的コンポーネント
`v-if` や`v-show` などを使って条件分岐で表示を切り替えるよりも短い記述ができる  
`<component v-bind:is="コンポーネント名"></component>` のように記述すると、  
`is` 属性に渡された値をコンポーネント名として解釈して表示してくれる  
コンポーネント名の部分に変数を渡しておき、ユーザーの操作などに合わせて変数の値を変化させることで、  
シンプルな記述でコンポーネントの切り替えを実装できる

### 動的コンポーネントで切り替えられたときの挙動
動的コンポーネントの`is` 属性の切り替えによってコンポーネントが変更された場合、  
コンポーネントを削除・生成するのがデフォルトの仕様  
切り替えられるコンポーネントの内部でユーザーに操作をさせるとき、それが消えてしまうと困る場合がある  
切り替える際にコンポーネントが削除されないようにするには、`<keep-alive></keep-alive>`で 
動的コンポーネントを囲んでおく必要がある  

また、keep-aliveで囲まれた動的コンポーネントの表示・非表示のライフサイクルフックとして、  
`activated` と`deactivated` が用意されている

 