# commentary of training001
CDNを利用してVue.jsを導入し、基本的な構文を使ってみました。

## {{val}} マスタッシュ構文
dataオブジェクト内のメンバに置き換えるための構文です。  
タグの属性値に対しては利用できないので、htmlテキスト部分を置き換える場合に使います。

## v-bind
一方向データバインド。htmlタグの属性値に、dataオブジェクトのプロパティを代入できます。  
`v-bind:[html属性名]="[dataオブジェクト内のkey]"` のように記述します。  
`<input type="text" v-bind:value="text">` と記述すれば、  
このinputタグのvalueはvueインスタンスの data.text が代入されます。

## v-if, v-show
vueインスタンスのdataオブジェクトのboolean値によって、レンダリングするかしないかを切り替えられます。  
falseの場合に、v-ifはDOMから削除され、v-showはDOMを残したままcssのdisplay: none; で画面上から隠します。  

## v-for
タグの属性に`v-for="(value, key) in obj"`を渡すと、dataオブジェクトのobjの内容でループします。  
valueが先に来ることが注意点です。  

### v-for オブジェクトの最適化によるバグを回避する
v-for ディレクティブによって描画される要素は、データの変更時にも高速に描画できるように最適化されています。  
例えば、`['A', 'B', 'C']` の配列をv-for で描画した際に、他の要素も一緒に出力しているとします。  
そのとき、vueの処理でループ対象の配列の要素を並べ替えたり、削除したりすると、DOMも再描画されます。  
再描画は、「現在描画されている内容と、変更後のデータを使って描画したときのDOMとの差分を更新」することによって行われます。  
つまり、ループの対象のデータと描画上関係ない要素がループの中に含まれている場合、その要素は「変更なし」として、再描画の処理が行われなくなります。  
これを回避するため、データの変更により再描画が行われるときは、要素に一意なkeyをつけておき、そのkeyを持つDOMがひとかたまりの内容として再描画されるようにしておきます。  
サンプルとして、fruits 配列と vegetable 配列を、それぞれkey なしとkey ありでループさせています。  
inputタグに値を入れてから、要素の削除ボタンをクリックしてみると、fruitsのほうは、先頭の要素が削除されても、inputの内容が変わらないことが確認できます。

## v-on
`v-on:[イベントハンドラ名]="vueオブジェクトのメソッド"`で、  
イベント発生時にvueインスタンスのmethodsオブジェクトに登録した関数を実行できます。
methodsオブジェクトへの関数の登録の際、アロー構文ではなく`function() {}` を利用することが推奨されています。  
アロー構文で宣言してしまうと、関数スコープ内の`this` がvueインスタンスを参照しなくなってしまうためです。
`<button v-on:click="button_clicked">Click here</button>` とすると、
ボタンクリック時に、methodsオブジェクトに登録された`button_clicked`関数が実行されるようになります。

## v-model
双方向データバインド。html側の内容を変更すると、バインドされたvueインスタンスのdataオブジェクトの内容も書き換えられます。
~~~html
<input type="text" v-model="text" value="">
<div>{{text}}</div>
~~~
上記の記述で、テキストボックスの値を変更するとそれに合わせてdata.textの内容が変更され、  
それによってdivタグ内のマスタッシュ構文で差し込まれている内容も変化します。

## まとめ
とりあえずtraining001ではここまでを扱いました。
基本的な操作方法をさらっと流しただけなので、あまり身に付いた感じはしていません…
この先、もうちょっと具体的な実装に取り組んでいきたいです。
